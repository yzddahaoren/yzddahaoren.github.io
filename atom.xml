<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://g.yzddhr.me</id>
    <title>yzd-gridea</title>
    <updated>2020-01-06T10:53:37.637Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://g.yzddhr.me"/>
    <link rel="self" href="https://g.yzddhr.me/atom.xml"/>
    <subtitle>记录 :  思考 : 慎言</subtitle>
    <logo>https://g.yzddhr.me/images/avatar.png</logo>
    <icon>https://g.yzddhr.me/favicon.ico</icon>
    <rights>All rights reserved 2020, yzd-gridea</rights>
    <entry>
        <title type="html"><![CDATA[利用小内存主机安装typecho,wordpress,云盘等]]></title>
        <id>https://g.yzddhr.me/post/li-yong-xiao-nei-cun-zhu-ji-an-zhuang-typechowordpressyun-pan-deng</id>
        <link href="https://g.yzddhr.me/post/li-yong-xiao-nei-cun-zhu-ji-an-zhuang-typechowordpressyun-pan-deng">
        </link>
        <updated>2020-01-06T10:42:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>支持安装的程序有<strong>Typecho/WordPress/Zblog/Kodexplorer</strong><br>
支持的功能有备份和还原</p>
</blockquote>
<h2 id="环境安装">环境安装</h2>
<ol>
<li>项目地址:https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3</li>
<li>下载相关的脚本:</li>
</ol>
<pre><code>wget -N --no-check-certificate git.io/c.sh &amp;&amp; chmod +x c.sh &amp;&amp; bash c.sh
</code></pre>
<p><strong>程序会自动给你安装好<code>php,caddy,sqlite</code>等环境</strong></p>
<h2 id="使用">使用</h2>
<p>可以使用以下</p>
<pre><code>#一键安装typecho博客
bash c.sh -t

#一键安装wordpress博客
bash c.sh -w

#一键安装zblog博客
bash c.sh -z

#一键安装kodexplorer可道云
bash c.sh -k

#一键安装laverna印象笔记
bash c.sh -l

#一键整站备份（一键打包/www网站目录、含数据库）
bash c.sh -a

#一键安装v2ra*
bash c.sh -v

#一键安装rinetd bbr端口加速
bash c.sh -b
</code></pre>
<h2 id="设置伪静态">设置伪静态</h2>
<blockquote>
<p>Caddy配置文件路径/etc/dylanbai8/caddy/Caddyfile。</p>
</blockquote>
<ol>
<li>编辑配置文件</li>
</ol>
<p><code>vi /etc/dylanbai8/caddy/Caddyfile</code></p>
<ol start="2">
<li>写入内容</li>
</ol>
<pre><code>#Wordpress伪静态
rewrite {
  if {path} not_match ^\/wp-admin
  to {path} {path}/ /index.php?{query}
}

#Typecho伪静态
rewrite {
    if {path} not_match ^\/admin
    to {path} {path}/ /index.php?{query}
 }
</code></pre>
<ol start="3">
<li>重启<code>caddy</code><br>
<code>systemctl restart caddy</code></li>
</ol>
<h2 id="管理和卸载">管理和卸载</h2>
<ul>
<li>卸载</li>
</ul>
<pre><code>#卸载caddy
bash c.sh -unc

#卸载php+sqlite
bash c.sh -unp

#卸载v2ra*
bash c.sh -unv

#卸载rinetdbbr
bash c.sh -unb
</code></pre>
<ul>
<li>相关的管理命令</li>
</ul>
<pre><code>启动：systemctl start caddy
停止：systemctl stop caddy
重启：systemctl restart caddy

Caddy配置文件位置：/etc/dylanbai8

网站目录：/www
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[更新后的gridea的使用体验]]></title>
        <id>https://g.yzddhr.me/post/geng-xin-hou-de-gridea-de-shi-yong-ti-yan</id>
        <link href="https://g.yzddhr.me/post/geng-xin-hou-de-gridea-de-shi-yong-ti-yan">
        </link>
        <updated>2020-01-06T09:59:10.000Z</updated>
        <content type="html"><![CDATA[<p>今天更新了gridea的最新版本，从第一个版本也有挺久没用gridea的了，果然不出所料，速度卡的要死</p>
<h2 id="缺点">缺点</h2>
<ul>
<li>容易卡死（本人用的缩略图比较大）</li>
<li>反应速度太慢</li>
<li>设置选项太少</li>
</ul>
<p><strong>使用体验根本就是不甚理想</strong><br>
于是又下载回了老版本<br>
嗯，就是这样<br>
还是老版本比较方便<br>
毕竟一个纯净的博客只需要支持公式的markdown就是最高要求了，能怎么简洁还是怎么简洁的来比较好。<br>
好吧，又换了个版本，发现怎么每一个版本一个编辑器啊，说实话搞得挺乱的。<br>
当然还是很感谢作者带来的这么好的软件，当然是我电脑已经老化了。期待下一次优化可以自定义设置是否lazyload缩略图，不然真加载起来还是很慢的，而且很多其他的同时运行的软件就无响应了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装pleroma(基于docker)]]></title>
        <id>https://g.yzddhr.me/post/an-zhuang-pleromaji-yu-docker</id>
        <link href="https://g.yzddhr.me/post/an-zhuang-pleromaji-yu-docker">
        </link>
        <updated>2019-08-24T08:03:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>pleroma是一款分布式的社交网络系统,和twitter类似<br>
Pleroma支持ActivityPub，这意味着可以和Mastodon/Misskey上的用户进行互动.<br>
Pleroma的特点是：高性能/内存使用率低，低配置的机器有福了，跑不了Mastodon可以换用Pleroma。而且喜欢小巧/紧凑风格的人，应该会非常喜欢Pleroma的前端和一系列主题。</p>
</blockquote>
<p><strong>以下安装基于docker</strong></p>
<h2 id="环境">环境</h2>
<ul>
<li>docker</li>
<li>docker-compose</li>
<li>内存至少<code>1G</code></li>
</ul>
<h2 id="安装环境">安装环境</h2>
<p><strong>docker</strong></p>
<pre><code>curl -sSL https://get.docker.com/ | sh
service docker start
</code></pre>
<p><strong>docker-compose</strong></p>
<pre><code>curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>
<h2 id="项目构建">项目构建</h2>
<p><strong>可隆项目</strong><br>
<code>https://github.com/angristan/docker-pleroma.git</code><br>
<strong>进入下载的文件夹</strong><br>
编辑<code>docker-compose.yml</code>文件</p>
<pre><code>version: '2.3'

services:
  postgres:
    image: postgres:9.6-alpine
    container_name: pleroma_postgres
    restart: always
    environment:
      POSTGRES_USER: pleroma
      POSTGRES_PASSWORD: pleroma
      POSTGRES_DB: pleroma
    volumes:
      - ./postgres:/var/lib/postgresql/data

  web:
    build: .
    image: pleroma
    container_name: pleroma_web
    restart: always
    ports:
      - &quot;127.0.0.1:4000:4000&quot;
    volumes:
      - ./uploads:/pleroma/uploads
    depends_on:
      - postgres
</code></pre>
<blockquote>
<p>修改<code>POSTGRES_PASSWORD</code>参数成自己的密码(可选).</p>
</blockquote>
<p><strong>创建配置文件文件夹</strong></p>
<pre><code>mkdir uploads config
chown -R 911:911 uploads
</code></pre>
<p><strong>安装<code>citext</code> PostgreSQL插件</strong></p>
<pre><code>docker-compose up -d postgres
docker exec -i pleroma_postgres psql -U pleroma -c &quot;CREATE EXTENSION IF NOT EXISTS citext;&quot;
docker-compose down
</code></pre>
<p><strong>编辑<code>config/secret.exs</code>文件</strong></p>
<pre><code>use Mix.Config

config :pleroma, Pleroma.Web.Endpoint,
   http: [ ip: {0, 0, 0, 0}, ],
   url: [host: &quot;pleroma.domain.tld&quot;, scheme: &quot;https&quot;, port: 443],
   secret_key_base: &quot;&lt;use 'openssl rand -base64 48' to generate a key&gt;&quot;

config :pleroma, :instance,
  name: &quot;Pleroma&quot;,
  email: &quot;admin@email.tld&quot;,
  limit: 5000,
  registrations_open: true

config :pleroma, :media_proxy,
  enabled: false,
  redirect_on_failure: true,
  base_url: &quot;https://cache.domain.tld&quot;

# Configure your database
config :pleroma, Pleroma.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: &quot;pleroma&quot;,
  password: &quot;pleroma&quot;,
  database: &quot;pleroma&quot;,
  hostname: &quot;postgres&quot;,
  pool_size: 10
</code></pre>
<blockquote>
<p>修改如下参数</p>
</blockquote>
<ul>
<li><code>host</code></li>
<li><code>secret_key_base</code></li>
<li><code>email</code></li>
</ul>
<p><strong>生成镜像</strong></p>
<pre><code>docker-compose build
# or
docker build -t pleroma .          //(推荐)
</code></pre>
<h2 id="数据库设置">数据库设置</h2>
<p><strong>创建数据库</strong></p>
<pre><code>docker-compose run --rm web mix ecto.migrate
</code></pre>
<p><strong>复制密钥<code>secret.exs</code></strong></p>
<pre><code>docker-compose run --rm web mix web_push.gen.keypair  //复制产生的一串东西到`secret.exs`
</code></pre>
<p><strong>重新构建,写入密钥</strong></p>
<pre><code>docker-compose build
# or
docker build -t pleroma .
</code></pre>
<p><strong>启动实例</strong></p>
<pre><code>docker-compose up -d
</code></pre>
<p><strong>查看输出</strong></p>
<pre><code>docker logs -f pleroma_web
</code></pre>
<h2 id="nginx配置官方">nginx配置(官方)</h2>
<blockquote>
<p>配置如下</p>
</blockquote>
<pre><code># default nginx site config for Pleroma
#
# Simple installation instructions:
# 1. Install your TLS certificate, possibly using Let's Encrypt.
# 2. Replace 'example.tld' with your instance's domain wherever it appears.
# 3. Copy this file to /etc/nginx/sites-available/ and then add a symlink to it
#    in /etc/nginx/sites-enabled/ and run 'nginx -s reload' or restart nginx.

proxy_cache_path /tmp/pleroma-media-cache levels=1:2 keys_zone=pleroma_media_cache:10m max_size=10g
                 inactive=720m use_temp_path=off;

server {
    server_name    example.tld;

    listen         80;
    listen         [::]:80;

    # Uncomment this if you need to use the 'webroot' method with certbot. Make sure
    # that the directory exists and that it is accessible by the webserver. If you followed
    # the guide, you already ran 'mkdir -p /var/lib/letsencrypt' to create the folder.
    # You may need to load this file with the ssl server block commented out, run certbot
    # to get the certificate, and then uncomment it.
    #
    # location ~ /\.well-known/acme-challenge {
    #     root /var/lib/letsencrypt/;
    # }
    location / {
      return         301 https://$server_name$request_uri;
    }
}

# Enable SSL session caching for improved performance
ssl_session_cache shared:ssl_session_cache:10m;

server {
    server_name example.tld;

    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    ssl_session_timeout 5m;

    ssl_trusted_certificate   /etc/letsencrypt/live/example.tld/chain.pem;
    ssl_certificate           /etc/letsencrypt/live/example.tld/fullchain.pem;
    ssl_certificate_key       /etc/letsencrypt/live/example.tld/privkey.pem;

    # Add TLSv1.0 to support older devices
    ssl_protocols TLSv1.2;
    # Uncomment line below if you want to support older devices (Before Android 4.4.2, IE 8, etc.)
    # ssl_ciphers &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;
    ssl_ciphers &quot;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4&quot;;
    ssl_prefer_server_ciphers on;
    # In case of an old server with an OpenSSL version of 1.0.2 or below,
    # leave only prime256v1 or comment out the following line.
    ssl_ecdh_curve X25519:prime256v1:secp384r1:secp521r1;
    ssl_stapling on;
    ssl_stapling_verify on;

    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript application/activity+json application/atom+xml;

    # the nginx default is 1m, not enough for large media uploads
    client_max_body_size 16m;

    location / {
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_set_header Host $http_host;

	# this is explicitly IPv4 since Pleroma.Web.Endpoint binds on IPv4 only
	# and `localhost.` resolves to [::0] on some systems: see issue #930
        proxy_pass http://127.0.0.1:4000;

        client_max_body_size 16m;
    }

    location ~ ^/(media|proxy) {
        proxy_cache pleroma_media_cache;
        slice              1m;
        proxy_cache_key    $host$uri$is_args$args$slice_range;
        proxy_set_header   Range $slice_range;
        proxy_http_version 1.1;
        proxy_cache_valid  200 206 301 304 1h;
        proxy_cache_lock on;
        proxy_ignore_client_abort on;
        proxy_buffering on;
        chunked_transfer_encoding on;
        proxy_ignore_headers Cache-Control;
        proxy_hide_header Cache-Control;
        proxy_pass http://localhost:4000;
    }
}

</code></pre>
<p><strong>建议机器只开<code>25</code> <code>80</code> <code>443</code> 端口</strong></p>
<h2 id="nginx配置自行">nginx配置(自行)</h2>
<p><strong>安装nginx</strong></p>
<pre><code>apt install -y nginx certbot  
</code></pre>
<p><strong>添加储存库</strong></p>
<pre><code>sudo add-apt-repository ppa:certbot/certbot
</code></pre>
<p><strong>更新</strong></p>
<pre><code>sudo apt-get update
</code></pre>
<p><strong>安装证书插件</strong></p>
<pre><code>sudo apt-get install python-certbot-nginx
</code></pre>
<p><strong>编辑配置文件</strong></p>
<pre><code>nano /etc/nginx/conf.d/pleroma.conf
</code></pre>
<p><strong>反向代理</strong></p>
<pre><code>server {
    listen       80;
    server_name  pleroma.koko.cat;
    client_max_body_size 100M;

    location / {
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_set_header Host $http_host;
        proxy_pass http://127.0.0.1:4000;
    }
}
</code></pre>
<p><strong>签发证书</strong></p>
<pre><code>certbot --nginx --agree-tos --no-eff-email
</code></pre>
<h2 id="使用体验">使用体验</h2>
<p>先比较于<code>Mastodon</code>更简洁,更漂亮.kksk.<br>
<img src="https://img.hacpai.com/file/2019/08/lala.im20190820190140-2249d038.png" alt="lala.im20190820190140.png"><br>
<img src="https://img.hacpai.com/file/2019/08/lala.im20190820191625-231cefaa.png" alt="lala.im20190820191625.png"><br>
<img src="https://img.hacpai.com/file/2019/08/lala.im20190820191313-7e2011aa.png" alt="lala.im20190820191313.png"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发卡系统搭建]]></title>
        <id>https://g.yzddhr.me/post/fa-qia-xi-tong-da-jian</id>
        <link href="https://g.yzddhr.me/post/fa-qia-xi-tong-da-jian">
        </link>
        <updated>2019-08-19T12:59:21.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://img.hacpai.com/bing/20190220.jpg?imageView2/1/w/960/h/540/interlace/1/q/100" alt=""></figure>
<p>使用项目搭建自己的发卡系统</p>
<blockquote>
<p>项目地址:<br>
<a href="https://github.com/zlkbdotnet/zfaka">https://github.com/zlkbdotnet/zfaka</a></p>
</blockquote>
<p>本文使用的是基于docker搭建</p>
<h2 id="环境">环境</h2>
<ul>
<li>docker安装</li>
</ul>
<pre><code class="language-sh">curl -sSL https://get.docker.com/ | sh
service docker start
</code></pre>
<ul>
<li>安装docker-compose</li>
</ul>
<pre><code class="language-sh">curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>打印信息</p>
<pre><code class="language-sh">docker --help
</code></pre>
<p>有输出表示安安装成功.</p>
<h2 id="安装">安装</h2>
<blockquote>
<p>注意不能用内存呢太小的vps,内存不够建议设置虚拟内存,可以使用以下脚本设置虚拟swap分区</p>
</blockquote>
<p><strong>脚本不支持OpenVZ架构，安装会自动退出。</strong></p>
<pre><code class="language-sh">#!/usr/bin/env bash
#Blog:https://www.moerats.com/

Green=&quot;\033[32m&quot;
Font=&quot;\033[0m&quot;
Red=&quot;\033[31m&quot; 

#root权限
root_need(){
    if [[ $EUID -ne 0 ]]; then
        echo -e &quot;${Red}Error:This script must be run as root!${Font}&quot;
        exit 1
    fi
}

#检测ovz
ovz_no(){
    if [[ -d &quot;/proc/vz&quot; ]]; then
        echo -e &quot;${Red}Your VPS is based on OpenVZ，not supported!${Font}&quot;
        exit 1
    fi
}

add_swap(){
echo -e &quot;${Green}请输入需要添加的swap，建议为内存的2倍！${Font}&quot;
read -p &quot;请输入swap数值:&quot; swapsize

#检查是否存在swapfile
grep -q &quot;swapfile&quot; /etc/fstab

#如果不存在将为其创建swap
if [ $? -ne 0 ]; then
	echo -e &quot;${Green}swapfile未发现，正在为其创建swapfile${Font}&quot;
	fallocate -l ${swapsize}M /swapfile
	chmod 600 /swapfile
	mkswap /swapfile
	swapon /swapfile
	echo '/swapfile none swap defaults 0 0' &gt;&gt; /etc/fstab
         echo -e &quot;${Green}swap创建成功，并查看信息：${Font}&quot;
         cat /proc/swaps
         cat /proc/meminfo | grep Swap
else
	echo -e &quot;${Red}swapfile已存在，swap设置失败，请先运行脚本删除swap后重新设置！${Font}&quot;
fi
}

del_swap(){
#检查是否存在swapfile
grep -q &quot;swapfile&quot; /etc/fstab

#如果存在就将其移除
if [ $? -eq 0 ]; then
	echo -e &quot;${Green}swapfile已发现，正在将其移除...${Font}&quot;
	sed -i '/swapfile/d' /etc/fstab
	echo &quot;3&quot; &gt; /proc/sys/vm/drop_caches
	swapoff -a
	rm -f /swapfile
    echo -e &quot;${Green}swap已删除！${Font}&quot;
else
	echo -e &quot;${Red}swapfile未发现，swap删除失败！${Font}&quot;
fi
}

#开始菜单
main(){
root_need
ovz_no
clear
echo -e &quot;———————————————————————————————————————&quot;
echo -e &quot;${Green}Linux VPS一键添加/删除swap脚本${Font}&quot;
echo -e &quot;${Green}1、添加swap${Font}&quot;
echo -e &quot;${Green}2、删除swap${Font}&quot;
echo -e &quot;———————————————————————————————————————&quot;
read -p &quot;请输入数字 [1-2]:&quot; num
case &quot;$num&quot; in
    1)
    add_swap
    ;;
    2)
    del_swap
    ;;
    *)
    clear
    echo -e &quot;${Green}请输入正确数字 [1-2]${Font}&quot;
    sleep 2s
    main
    ;;
    esac
}
main
</code></pre>
<p><strong>保存并命名为swap.sh</strong><br>
<code>bash swap.sh</code>即可.<br>
<code>free -m</code>查看内存.</p>
<h2 id="命令">命令</h2>
<p>docker各种镜像关系如图:<br>
<img src="https://img.hacpai.com/file/2019/08/p-2f6fd591.png" alt="p.png"></p>
<ul>
<li>利用<code>docker-compose</code>部署</li>
</ul>
<pre><code class="language-sh">wget https://raw.githubusercontent.com/Baiyuetribe/zfaka/docker/docker-compose.yml
</code></pre>
<pre><code>docker-compose up -d
</code></pre>
<p><strong>端口说明</strong></p>
<ul>
<li>ZFAKA主程序入口为：http://域名:3002 打开后填入数据库密码即可完成安装步骤。</li>
<li>phpadmin入口：http://域名:8080 用来修改数据库</li>
<li>kodexplore入口：http://域名:999 用来管理源码或替换图片等等。<br>
<strong>可能问题</strong><br>
<img src="https://img.hacpai.com/file/2019/08/68747470733a2f2f696d672e6261697975652e6f6e652f75706c6f61642f323031392f30372f356431633839363037373530322e706e67-985c198b.png" alt="68747470733a2f2f696d672e6261697975652e6f6e652f75706c6f61642f323031392f30372f356431633839363037373530322e706e67.png"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[亚历山大大帝是否真实存在]]></title>
        <id>https://g.yzddhr.me/post/ya-li-shan-da-da-di-shi-fou-zhen-shi-cun-zai</id>
        <link href="https://g.yzddhr.me/post/ya-li-shan-da-da-di-shi-fou-zhen-shi-cun-zai">
        </link>
        <updated>2019-08-15T11:45:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>个人观点: 亚历山大不存在</strong><br>
亚历山大被誉为西方的战神，他是亚历山大帝国的建立者，也是波斯帝国的掘墓人。直到现在关于亚历山大东征的故事，在中西方流传很广。</p>
<p>但是就是这样一个伟大的战神，却遭到很多历史爱好者的质疑。很多人说亚历山大是虚拟的，也根本不存在什么亚历山大帝国。他们为什么得出这个结论，小编在此给大家分析下：<br>
<img src="https://g.yzddhr.me/post-images/1565869711930.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗?</p>
<p>一、被亚历山大征服的地方，没有任何信史记载</p>
<p>亚历山大一生征服过许多地方，古代埃及、两河流域地区、古代波斯和古代印度地区。应该说这么大规模的征服行动，古希腊和被征服的地方应该有信史记载。</p>
<p>但是不管是希腊还是埃及、印度、波斯和巴比伦，都没有原始的信史记载被亚历山大征服。唯一可以证明的就是文艺复兴时期翻译的所谓的阿拉巴史料，但是阿拉伯史料原本据说丢了。<br>
<img src="https://g.yzddhr.me/post-images/1565869721728.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗</p>
<p>二、波斯帝国不是亚历山大所灭</p>
<p>根据伊朗历史的记载，波斯帝国真正灭亡的原因是：公元前337年阿塔薛西斯三世之子阿勒西斯全家被杀，大流士三世被拥立为王，很多人并不认可大流士三世的统治。</p>
<p>波斯统治的地区各自拥兵自重，中央与地方矛盾日益尖锐。此时埃及人、马其顿人、巴比伦人、亚述人纷纷起来反叛，在内忧外患下波斯王朝最终解体。<br>
<img src="https://g.yzddhr.me/post-images/1565869767013.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗</p>
<p>三、波斯地区希腊化是一个谎言</p>
<p>波斯在中国古代被称为大食，很早就与中国有贸易往来，战国时期的赵国就有商人到波斯做玉石生意，但是从未记载过大食被谁征服的事情。</p>
<p>如果亚历山大真的征服了波斯，对于喜欢修史的中国人，一定会提及这段历史。由于现代的伊朗没有话语权，他们的历史被淹没在西方人编造的故事里，波斯文明被强行希腊化。<br>
<img src="https://g.yzddhr.me/post-images/1565869788329.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗</p>
<p>四、亚历山大东征，就是一群流寇造反的故事</p>
<p>大流士三世的统治的时候，埃及人、马其顿人、巴比伦人、亚述人都起来造反，难免会出现几个比较牛逼的头目，他们带领着反叛武装，一路趁机烧杀抢掠。亚历山大东征，就是一群流寇造反的故事。</p>
<p>如果亚历山大东征是真实的，那么从希腊半岛到印度，几千公里他的补给是怎么解决的？1812年拿破仑入侵沙俄，30万人掉队病号减员95000人，战斗损失14万多人，而亚历山大要比拿破仑早2000多年。<br>
<img src="https://g.yzddhr.me/post-images/1565869798681.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗</p>
<p>五、亚历山大征服了所有的古文明，为何放过中国</p>
<p>亚历山大一生征服了埃及、巴比伦、印度、波斯，如果再加上希腊，除了中国几乎所有的古文明都被征服，他为何单独放过了中国？而上述几个被征服的地区，有一个共同点就是都没有完整的信史保留。</p>
<p>而中国有着世界上最完整的信史记载，如果亚历山大东征是文艺复兴时期杜撰的，杜撰者就无法杜撰亚历山大征服中国的故事。因为我们的信史不但记载我们历史的辉煌，也记载我们被入侵的历史。<br>
<img src="https://g.yzddhr.me/post-images/1565869842187.jpg" alt=""><br>
亚历山大为什么遭到质疑，他建立的庞大帝国真的存在吗</p>
<p>更让人不可思议的是亚历山大死后，他建立的庞大的亚历山大帝国在同一年就消亡。就好像这个国家的存在，就是为了证明亚历山大的伟大，其他没有任何意义。</p>
<p>如果亚历山大这个人真是虚拟的，那么所谓的亚历山大帝国就根本不存在。在信息化如此透明的今天，在西方白头盔公然造假都能获得奥斯卡奖。那么在信息封闭的古代，就没有什么不可杜撰的了.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git配置多账号]]></title>
        <id>https://g.yzddhr.me/post/git-pei-zhi-duo-zhang-hao</id>
        <link href="https://g.yzddhr.me/post/git-pei-zhi-duo-zhang-hao">
        </link>
        <updated>2019-08-15T11:17:40.000Z</updated>
        <content type="html"><![CDATA[<p>最近搞了一个edu结尾的域名，撸了一个无限前缀的edu邮箱，自然是去申请github包，没想到现在的github学生包已经不支持简单的edu邮箱了，我2018年申请的时候还是直接通过，根本不需要证明啥的，唉，既然学生包不能申请，就当普通的github账号用吧，顺便搭建一个博客的备份。所以就需要配置多用户本地使用。</p>
<h2 id="环境">环境</h2>
<ul>
<li>Windows 10</li>
<li>git</li>
<li>github</li>
</ul>
<h2 id="步骤">步骤</h2>
<h3 id="ssh-key生成">SSH KEY生成</h3>
<p><strong>1. 申请github账号</strong><br>
现在的github是真的大方，免费的个人仓库无限使用。我还是能说什么？基佬网万岁！:heart<br>
<strong>2. SSH kEY配置</strong><br>
<strong>2.1 第一个 SSH Key 的生成</strong><br>
打开 git bash，输入以下命令生成 github-user1 的 SSH Key：</p>
<pre><code>ssh-keygen -t rsa -C &quot;github-user1@email.com&quot;
</code></pre>
<p>第一个 ssh key 使用默认名字，三下回车，完成第一个默认的 ssh key。<br>
在当前用户目录的 .ssh 目录下会生成 id_rsa 私钥文件和 id_rsa.pub 公钥文件，将 id_rsa.pub 公钥中的内容添加至 github-user1 的 GitHub 云端中。<br>
然后在 git bash 中输入以下命令测试该用户的 SSH 密钥是否有效：</p>
<pre><code>ssh -T git@github.com
</code></pre>
<p>若连接成功则提示</p>
<blockquote>
<p>Hi github-user1! You've successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p><strong>2.2 第二个 SSH KEY生成</strong><br>
git bash 中输入以下命令，生成 gitee-user1 的密钥，注意第二个 SSH Key 不能再使用默认的文件名 id_rsa，否则会覆盖之前的密钥文件：</p>
<pre><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitee_one -C &quot;gitee-user1@email.com&quot;
</code></pre>
<p>在当前用户目录的 .ssh 目录下会生成 id_rsa_gitee_one 私钥文件和 id_rsa_gitee_one.pub 公钥文件，将 id_rsa_gitee_one.pub 公钥中的内容添加至 gitee-user1 的 Gitee 云端中。</p>
<h3 id="ssh配置">SSH配置</h3>
<p>在 .ssh 目录下创建一个 config 文本文件，每个账号配置一个Host节点，主要配置项说明：</p>
<pre><code>Host    　    #　主机别名
HostName　    #　服务器真实地址
IdentityFile　#　私钥文件路径
PreferredAuthentications　#　认证方式
User　        #　用户名
</code></pre>
<p><strong>config 文件内容：</strong></p>
<pre><code># ~/.ssh/config 配置多个git的ssh-key
# 第一个默认的SSH Key
Host github.com
    HostName github.com
    IdentityFile C:\\Users\\Administrator\\.ssh\\id_rsa
    PreferredAuthentications publickey
# 第二个SSH Key
Host gitee.com
    HostName gitee.com
    IdentityFile C:\\Users\\Administrator\\.ssh\\id_rsa_gitee_one
    PreferredAuthentications publickey
</code></pre>
<h3 id="测试连接">测试连接</h3>
<pre><code>ssh -T git@github.com
ssh -T git@gitee.com
</code></pre>
<h3 id="本地仓库配置">本地仓库配置</h3>
<p><strong>3.1 删除本地的原来配置</strong><br>
进入相关的仓库</p>
<pre><code># github.com域
git remote rm origin
git remote add origin git@two.github.com:github-user2/text.git

# gitee.com域
git remote rm origin
git remote add origin git@two.gitee.com:gitee-user2/text.git
</code></pre>
<p><strong>3.2 设置新的用户和密码</strong><br>
进入相关的仓库<br>
分别在各仓库下配置相应的用户名和邮箱</p>
<pre><code>git config user.name &quot;username&quot;
git config user.email &quot;username@email.com&quot;
</code></pre>
<blockquote>
<p>这样就完事了,可以用原来的git push等命令了.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[免费一年的focusky的激活码]]></title>
        <id>https://g.yzddhr.me/post/mian-fei-yi-nian-de-focusky-de-ji-huo-ma</id>
        <link href="https://g.yzddhr.me/post/mian-fei-yi-nian-de-focusky-de-ji-huo-ma">
        </link>
        <updated>2019-08-14T10:50:51.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>关于focusky的介绍就不要了吧,非常好用的PPT软件,素材很多</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>关于focusky的介绍就不要了吧,非常好用的PPT软件,素材很多</p>
</blockquote>
<!-- more -->
<p>下面介绍特别版注册:<strong>截至有效期2019年9月15日</strong>.<br>
介绍:<br>
https://www.iplaysoft.com/focusky-zhu-ce-ma.html<br>
超级激活码：E02C-92AD-595E-99EC-735C<br>
激活码有效期：即日起至2019年09月15日<br>
激活后特别版有效期：365天特别版的升级<br>
1、电脑打开 <a href="http://www.focusky.com.cn/account/register?iCode=pugwh">http://www.focusky.com.cn/account/register?iCode=pugwh</a> ，注册后，登录你的账号，进入“账号升级”后台激活升级。<br>
2、升级后，打开Focusky软件，登录已升级的账号，就能获得特别版的使用权限。这里需要注意，若升级前正使用账号登录Focusky，升级后，软件上依然显示免费版，那么请先退出账号，重新登录即可。</p>
<p>邮箱可以使用临时邮箱<br>
<a href="aws.yzddhr.me:3000">aws.yzddhr.me:3000</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[太喜欢这个欢乐沙雕漂亮的小改改了！]]></title>
        <id>https://g.yzddhr.me/post/tai-xi-huan-zhe-ge-huan-le-sha-diao-piao-liang-de-xiao-gai-gai-liao</id>
        <link href="https://g.yzddhr.me/post/tai-xi-huan-zhe-ge-huan-le-sha-diao-piao-liang-de-xiao-gai-gai-liao">
        </link>
        <updated>2019-08-14T10:49:09.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.instagram.com/celinefarach">https://instagram.com/celinefarach</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.instagram.com/celinefarach">https://instagram.com/celinefarach</a></p>
<!-- more -->
<p>特别是这个视频：<br>
<a href="https://img.hacpai.com/file/2019/08/690089543912468451260041678916118869249833n-c5e28855.mp4">690089543912468451260041678916118869249833n.mp4</a><br>
还能说什么呢？<br>
生活或许很美好？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axel-corn下载服务器]]></title>
        <id>https://g.yzddhr.me/post/axel-corn-xia-zai-fu-wu-qi</id>
        <link href="https://g.yzddhr.me/post/axel-corn-xia-zai-fu-wu-qi">
        </link>
        <updated>2019-08-14T10:48:05.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>axel-corn 无意间发现的下载器,基于的是axel的下载工具,这个都知道多线程下载器嘛,好用就完事了,这个项目主要是方便自己的网页短操作.就是这样.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>axel-corn 无意间发现的下载器,基于的是axel的下载工具,这个都知道多线程下载器嘛,好用就完事了,这个项目主要是方便自己的网页短操作.就是这样.</p>
</blockquote>
<!-- more -->
<h2 id="环境">环境</h2>
<ul>
<li>python</li>
</ul>
<p>// python的作用主要是就是开一个web ,静态的 ,当然,你说我用caddy不行啊?那当然可以,比起来还是自带的python更方便而已.</p>
<h2 id="下载安装">下载安装</h2>
<pre><code>下载和编译:
$ git clone https://github.com/lihaoyun6/axeldown-core.git
$ cd axeldown-core
$ chmod a+x build.sh
$ ./build.sh

</code></pre>
<h2 id="环境准备">环境准备:</h2>
<p>因为项目基于web.py模块提供服务, 故需要先安装web.py</p>
<pre><code>$ sudo easy_install web.py
</code></pre>
<p>启动运行:</p>
<pre><code>$ cd axeldown-core
$ python axeldown.py [自定义端口]
</code></pre>
<p>例如</p>
<pre><code>$ python axeldown.py 2333
</code></pre>
<p>(不使用自定义端口时, 默认在8080端口开启服务)</p>
<p>启动服务后在浏览器中打开&quot;<a href="http://127.0.0.1:%E7%AB%AF%E5%8F%A3/">http://127.0.0.1:端口</a>&quot;即可看到管理界面<br>
<img src="https://img.hacpai.com/file/2019/08/run-ead3f1f5.jpg" alt="run.jpg"></p>
<h2 id="结合百度云">结合百度云</h2>
<p><strong>1. 先解析</strong><br>
进入下面的连接,解析下百度云的分享文件.<br>
<a href="https://labs.nazo.moe/netdisk.html">https://labs.nazo.moe/netdisk.html</a><br>
得到图片这样的一串东西,这个是给<code>ari2c</code>用的,但是下载链接看得出来是哪个吧,把下载链接单独拿出来,就可以了.<br>
<img src="https://img.hacpai.com/file/2019/08/20-b9449b6e.png" alt="20.png"></p>
<h2 id="其他">其他</h2>
<p>顺便说一句,搭配<code>ALOOK</code>,这个搜一下,是<code>IOS</code>的一个浏览器,可以直接解析出某<code>ProXXub</code>的视频的<code>CDN</code>下载链接,这个链接用国内的<code>vps</code>也能下载,速度超快,当然你用IDM也行,但是因为是手机端的操作,这个<code>axel-corn</code>肯定是好用多了.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[色图pixiv下载器]]></title>
        <id>https://g.yzddhr.me/post/se-tu-pixiv-xia-zai-qi</id>
        <link href="https://g.yzddhr.me/post/se-tu-pixiv-xia-zai-qi">
        </link>
        <updated>2019-08-14T10:46:47.000Z</updated>
        <summary type="html"><![CDATA[<p>pixiv,知名色图网站,另一解释的P小将.主要就是没事下载个色图康康,毕竟搞黄色是人类去世的阶梯,当然是高尔基说的,不关我事,</p>
]]></summary>
        <content type="html"><![CDATA[<p>pixiv,知名色图网站,另一解释的P小将.主要就是没事下载个色图康康,毕竟搞黄色是人类去世的阶梯,当然是高尔基说的,不关我事,</p>
<!-- more -->
<p>但是倒的确是是这样,谁不想快点去世呢?大部人还是活着受罪的啊,毕竟.</p>
<blockquote>
<p>pixiv : 色图站,没啥好说的.</p>
</blockquote>
<h2 id="环境">环境</h2>
<ul>
<li>python</li>
<li>node</li>
</ul>
<h2 id="安装">安装</h2>
<h3 id="脚本">脚本</h3>
<p><strong>1. 使用一键脚本</strong></p>
<blockquote>
<p>注意的是,一键脚本只能下载每日排行榜,当然还是正常的榜,R18榜是不能下的.但是还是挺方便的,毕竟不需要登陆的. ❤️</p>
</blockquote>
<p><strong>2. 下载脚本</strong></p>
<pre><code>wget https://raw.githubusercontent.com/MoeClub/Pixiv/master/pixiv.py
</code></pre>
<p>脚本默认<code>25</code>线程，想改的话，直接编辑脚本，搜索<code>25</code>，改成相应数字就可以了。</p>
<p><strong>3. 使用脚本</strong></p>
<pre><code>#下载画师原图，使用画师UID即可
python3 pixiv.py &quot;673179&quot; 
   
#下载排行榜原图，使用排行榜地址即可    
python3 pixiv.py &quot;https://www.pixiv.net/ranking.php?mode=male&quot;  //可改女性排行榜,不可R18 :滑稽
</code></pre>
<h3 id="pxder">pxder</h3>
<p><strong>1. pxder</strong></p>
<blockquote>
<p>还算挺好用的下载器吧,主要就是下载自己的收藏夹挺方便的,其他的功能的话,下载画师啥的,还行吧,应该,不过没用过.</p>
</blockquote>
<p><strong>2. 安装node</strong></p>
<pre><code>#Debian/Ubuntu系统 

curl -sL https://deb.nodesource.com/setup_10.x | bash - 
apt install -y git nodejs 

#CentOS系统 

curl -sL https://rpm.nodesource.com/setup_10.x | bash - 
yum install nodejs git -y
</code></pre>
<h2 id="安装更新卸载">安装/更新/卸载</h2>
<p>打开“命令提示符”或者“Powershell”，执行下面的命令，即可安装或者更新（注：后续命令皆为在此执行）</p>
<pre><code class="language-bash">npm i -g pxder
</code></pre>
<p>如需卸载，执行</p>
<pre><code class="language-bash">npm uninstall -g pxder
</code></pre>
<h2 id="配置">配置</h2>
<h3 id="登录">登录</h3>
<pre><code class="language-bash">pxder --login
</code></pre>
<p>然后会让你输入用户名密码，登录成功一次后以后如果没有出什么bug则无需再次登录</p>
<p>注：pxder 仅会在计算机上储存 refreshAccessToken，而不会储存您的帐号密码</p>
<p>如果要登出</p>
<pre><code class="language-bash">pxder --logout
</code></pre>
<h3 id="设置">设置</h3>
<p>进入 Pxder 的设置界面</p>
<pre><code class="language-bash">pxder --setting
</code></pre>
<p>有五项设置，按下数字键选择一项进行设置，然后按照要求输入之后回车即可</p>
<pre><code class="language-bash">[1] Download path     # 下载目录，必须设置
[2] Download thread   # 下载线程数
[3] Download timeout  # 下载超时
[4] Auto rename       # 自动重命名（文件夹）
[5] Proxy             # 使用代理
</code></pre>
<ul>
<li>
<p><strong>下载目录</strong><br>
请注意相对路径与绝对路径的区别，不过不用担心，输入完路径后会显示绝对路径以方便你检查<br>
目录无需手动建立，下载图片的时候会自动建立</p>
</li>
<li>
<p><strong>下载线程数</strong><br>
即同时下载的图片数，默认为<code>5</code>，最小为<code>1</code>，最大为<code>32</code><br>
下载图片时最左侧的一列实际上就是线程编号</p>
</li>
<li>
<p><strong>下载超时及重试</strong><br>
如果这么多秒之后一张图还没被下载完则算作超时，超时后会自动重试，默认值为<code>30</code><br>
下载图片时如果线程编号是黄色底的就代表此次是重试<br>
重试超过<code>10</code>次则视作下载失败</p>
</li>
<li>
<p><strong>自动重命名</strong><br>
开启了以后，例如这个画师原来叫<code>abc</code>，今天你再次去下载（更新）他的画作，但是他改名叫<code>def</code>了，那么程序会自动帮你重命名画师文件夹</p>
</li>
<li>
<p><strong>使用代理</strong><br>
支持使用 HTTP 或 SOCKS 代理，即可以使用小飞机<br>
输入格式为<code>&lt;协议&gt;://[用户名:密码@]&lt;IP&gt;:&lt;端口&gt;</code>，例如：</p>
<ul>
<li><code>http://user:passwd@127.0.0.1:1080</code></li>
<li><code>socks://127.0.0.1:1080</code>（如果你使用小飞机则直接填这个，除非你改过本地端口）</li>
</ul>
<p>如果输入空行则关闭代理</p>
</li>
</ul>
<p>注：配置文件存放路径可通过命令<code>pxder --conf-loca</code>查看</p>
<h2 id="说明">说明</h2>
<ul>
<li>由于官方客户端 API 限制 offset 不能大于 5000，所以程序不会也无法得到画师列表、画作列表、收藏列表等 5000 页以后的数据，并且由该原因导致的程序崩溃问题已经在 v2.7.3 修复</li>
<li>会将同一画师的作品下载在<code>(UID)画师名</code>格式的文件夹内，图片命名格式为<code>(PID)作品名</code><br>
并且，画师名会自动删除名字中<code>@</code>（包含半角&amp;全角）符号及以后的文字（因为这些基本上都是画师的摊位信息之类的与名字无关的信息）</li>
<li>文件（夹）名均会过滤掉所有 Windows 和 Linux 中不能或不推荐做文件名的符号</li>
<li>动图下下来会是所有帧的压缩包，并且会标注 delay 信息
<ul>
<li>例如<code>xxx@30ms.zip</code>表示该动图的播放速度为 30ms 一帧</li>
<li>由于获取动图信息需要额外调用API，因此如果动图较多将会使得解析时间较长</li>
</ul>
</li>
<li>下载时会忽略掉已经下载完成的插画</li>
<li>下载超时或网络错误会自动重试，重试上限为10次
<ul>
<li>如果当某一个线程达到重试上限并且此时有不止一个下载线程处于重试状态，程序将视为暂时出现了网络问题，暂停5分钟后会继续重试</li>
<li>如果只有一个下载线程出现错误，程序将会放弃下载该p并继续运行（因为有出现过确实是因为P站自己的问题而无法下载的例子<code>48948784_p4</code>）</li>
</ul>
</li>
<li>抗GFW连接重置攻击，解析时被连接重置会自动重试</li>
</ul>
<h2 id="正式使用">正式使用</h2>
<p>如果需要终止程序，请在命令行中按下<code>Ctrl + C</code>或者直接关闭命令行窗口</p>
<p>请不要吐槽为什么在 Windows 下<code>Ctrl + C</code>后提示的<code>终止批处理操作吗(Y/N)?</code>不管是 Y 还是 N 都依然会终止，因为 nodejs 捕捉到<code>Ctrl + C</code>就自己终止了，Windows 晚了一步（。</p>
<h3 id="1-下载或更新某画师的所有插画作品">(1) 下载或更新某画师的所有插画作品</h3>
<p>使用<code>-u</code>或<code>--uid</code>参数，后跟画师的 UID，可单个可多个，如果多个则用英文半角逗号隔开</p>
<pre><code class="language-bash">pxder -u uid1,uid2,uid3,...
</code></pre>
<p>例如</p>
<pre><code class="language-bash">pxder -u 5899479,724607,11597411
</code></pre>
<h3 id="2-下载或更新你关注的所有画师的所有插画作品">(2) 下载或更新你关注的所有画师的所有插画作品</h3>
<p>该操作同时也会更新已下载的关注画师的作品，并且效率远高于 (3)，比较推荐使用</p>
<p>会自动排除 pixiv事務局 (uid=<code>11</code>)</p>
<p>由于收集关注信息需时较久，因此特地针对该功能做了信息缓存：如果你在下载中途退出，那么下次使用该功能时并不需要重新收集，而是利用上次的缓存立即继续下载。</p>
<ul>
<li>公开关注与私密关注的缓存是分开的，互不干扰</li>
<li>如果你需要强制重新收集画师信息（忽略上次的缓存），请在运行命令时加入<code>--force</code>参数</li>
</ul>
<h4 id="公开关注的画师">公开关注的画师</h4>
<pre><code class="language-bash">pxder -f
# 或
pxder --follow
</code></pre>
<h4 id="私密关注的画师">私密关注的画师</h4>
<pre><code class="language-bash">pxder -F
# 或
pxder --follow--private
</code></pre>
<h3 id="3-更新已下载的画师的画作">(3) 更新已下载的画师的画作</h3>
<p>会对下载目录中检测到的所有下载过的画师的插画进行增量更新下载</p>
<p>与 (2) 的区别是可以更新你使用 (1) 下载了的但是未关注的画师的插画，但是效率远低于 (2)</p>
<pre><code class="language-bash">pxder -U
# 或
pxder --update
</code></pre>
<h3 id="4-下载或更新你的收藏中的插画作品">(4) 下载或更新你的收藏中的插画作品</h3>
<h4 id="公开收藏">公开收藏</h4>
<p>插画会被下载至<code>[bookmark] Public</code>文件夹中</p>
<pre><code class="language-bash">pxder -b
# 或
pxder --bookmark
</code></pre>
<h4 id="私密收藏">私密收藏</h4>
<p>插画会被下载至<code>[bookmark] Private</code>文件夹中</p>
<pre><code class="language-bash">pxder -B
# 或
pxder --bookmark--private
</code></pre>
<h3 id="5-根据指定-pid-下载插画">(5) 根据指定 PID 下载插画</h3>
<p>插画会被下载至<code>PID</code>文件夹中</p>
<pre><code class="language-bash">pxder -p pid1,pid2,pid3,...
</code></pre>
<p>例如</p>
<pre><code class="language-bash">pxder -p 70593670,70594912,70595516
</code></pre>
]]></content>
    </entry>
</feed>